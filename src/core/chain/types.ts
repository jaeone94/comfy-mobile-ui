/**
 * Workflow Chain Types
 *
 * Type definitions for the workflow chain feature that allows connecting
 * multiple workflows in a node-style graph where outputs from one workflow
 * become inputs for another.
 */

/**
 * Chain execution status
 */
export type ChainExecutionStatus =
  | 'pending'
  | 'running'
  | 'completed'
  | 'failed'
  | 'cancelled';

/**
 * Chain node execution status
 */
export type ChainNodeExecutionStatus =
  | 'pending'
  | 'running'
  | 'completed'
  | 'failed';

/**
 * Chain input binding type - static or dynamic
 */
export type ChainInputBindingType = 'static' | 'dynamic';

/**
 * Chain widget type for input/output detection
 */
export type ChainWidgetType = 'image' | 'video';

/**
 * Chain output type from executed nodes
 */
export type ChainOutputType = 'image' | 'video';

/**
 * Chain input binding configuration
 * Defines how an input parameter is bound - either to a static value or to another workflow's output
 */
export interface IChainInputBinding {
  /** Node ID in the API workflow (the input node within this workflow) */
  nodeId: string;

  /** Node title for display purposes */
  nodeTitle?: string;

  /** Widget name (e.g., "image", "video") */
  widgetName: string;

  /** Widget type */
  widgetType: ChainWidgetType;

  /** Current static value (file path) */
  currentValue: string;

  /** Binding type - static or dynamic */
  bindingType: ChainInputBindingType;

  /** Source ChainWorkflowNode ID (which workflow node in the chain, if dynamic) */
  sourceChainNodeId?: string;

  /** Source OutputNode's nodeId within that workflow (which output node in that workflow, if dynamic) */
  sourceOutputNodeId?: string;
}

/**
 * Chain output node definition
 * Represents a node in the workflow that produces output files
 */
export interface IChainOutputNode {
  /** Node ID in the API workflow */
  nodeId: string;

  /** Node title for display purposes */
  nodeTitle?: string;

  /** Value of filename_prefix widget */
  filenamePrefix: string;

  /** Expected output type (image or video) */
  outputType: ChainOutputType;
}

/**
 * Chain workflow node
 * Represents a single workflow within the chain with its input/output configuration
 */
export interface IChainWorkflowNode {
  /** Unique node identifier in the chain */
  id: string;

  /** Reference to original workflow (optional, for tracking) */
  workflowId?: string;

  /** API-formatted workflow JSON */
  apiWorkflow: any;

  /** Input parameter bindings */
  inputBindings: IChainInputBinding[];

  /** Output node definitions */
  outputNodes: IChainOutputNode[];

  /** Node position for UI (optional) */
  position?: {
    x: number;
    y: number;
  };

  /** Display name for the node */
  name?: string;

  /** Thumbnail URL for visual representation */
  thumbnail?: string;
}

/**
 * Workflow Chain
 * Main structure representing a complete chain of workflows
 */
export interface IWorkflowChain {
  /** Unique chain identifier */
  id: string;

  /** User-friendly chain name */
  name: string;

  /** Optional description */
  description?: string;

  /** Creation timestamp */
  createdAt: Date;

  /** Last modification timestamp */
  modifiedAt: Date;

  /** Array of workflow nodes in the chain */
  nodes: IChainWorkflowNode[];
}

/**
 * Chain executed output information
 * Contains information about a file generated by a workflow execution
 */
export interface IChainExecutedOutput {
  /** Output node ID in the workflow */
  nodeId: string;

  /** Output type (image or video) */
  type: ChainOutputType;

  /** Generated filename */
  filename: string;

  /** Subfolder in outputs directory */
  subfolder: string;

  /** Original path in outputs folder */
  originalPath: string;

  /** Cached path in inputs/chain_result folder */
  cachedPath: string;
}

/**
 * Chain node execution result
 * Contains the result of executing a single workflow node in the chain
 */
export interface IChainNodeExecutionResult {
  /** Chain workflow node ID */
  nodeId: string;

  /** Execution status */
  status: ChainNodeExecutionStatus;

  /** ComfyUI prompt ID */
  promptId?: string;

  /** Execution start time */
  startedAt?: Date;

  /** Execution completion time */
  completedAt?: Date;

  /** Generated outputs */
  outputs?: IChainExecutedOutput[];

  /** Error message if failed */
  error?: string;
}

/**
 * Chain execution state
 * Tracks the overall state of a chain execution
 */
export interface IChainExecutionState {
  /** Chain ID being executed */
  chainId: string;

  /** Overall execution status */
  status: ChainExecutionStatus;

  /** Current node index being executed */
  currentNodeIndex: number;

  /** Total number of nodes in the chain */
  totalNodes: number;

  /** Execution start time */
  startedAt?: Date;

  /** Execution completion time */
  completedAt?: Date;

  /** Error message if failed */
  error?: string;

  /** Results for each node execution */
  nodeExecutions: IChainNodeExecutionResult[];
}

/**
 * Chain execution context (used internally during chain execution)
 * Maintains state and cached outputs during chain execution
 */
export interface IChainExecutionContext {
  /** Execution ID */
  executionId: string;

  /** Chain being executed */
  chain: IWorkflowChain;

  /** Cache of outputs: Map<(chainNodeId, outputNodeId), cachedPath> */
  outputCache: Map<string, string>;

  /** Client ID for WebSocket connection */
  clientId: string;
}

/**
 * Chain validation result
 */
export interface IChainValidationResult {
  /** Whether the chain is valid */
  valid: boolean;

  /** Array of validation error messages */
  errors: string[];

  /** Array of validation warning messages */
  warnings?: string[];
}

/**
 * Helper function to create cache key for output lookup
 */
export function createOutputCacheKey(chainNodeId: string, outputNodeId: string): string {
  return `${chainNodeId}:${outputNodeId}`;
}

/**
 * Helper function to parse cache key
 */
export function parseOutputCacheKey(key: string): { chainNodeId: string; outputNodeId: string } | null {
  const parts = key.split(':');
  if (parts.length !== 2) return null;
  return {
    chainNodeId: parts[0],
    outputNodeId: parts[1]
  };
}